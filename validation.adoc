= Validation systématique


[quote]
Un bon programme fait ce qu'on lui demande, un excellent programme refuse ce qu'il n'est pas sensé faire

== Périmètre

Une application est segmentée en composants (techniques, fonctionnels, systèmes applicatifs, internes, externes...)

[IMPORTANT]
====
Il faut identifier de manière *exaustive* et synthétique *chaque point d'entrée* et de sortie de *chaque composant*
====

Cette phase est vitale, car elle permet de construire l'inventaire des éléments à vérifier.

== Vérification intégrale de chaque donnée entrée

[quote]
Never trust anything, build defensive

Que ce soit pour par erreur, malveillance, ou oubli, n'importe quel élément peut recevoir des données différentes de celles attendues.

[IMPORTANT]
====
Il faut vérifier *systématiquement* toute donnée entrante, de manière *exaustive* et *contraignante* afin d'être soit acceptée si conforme, ou rejetée si invalide.
====

== Quoi vérifier ?

Tous les éléments sont concernées par cette vérification :

* les programmes et les scripts
* les IHM
* les interfaces programmables (api, webservices)
* les classes et fonctions
* les variables accessibles dans le scope
* ...

[IMPORTANT]
====
Pour les *programmes* et les *scripts* : il faut vérifier les *arguments*, les *fichiers*, et l'*entrée standard*
====

[IMPORTANT]
====
Pour les *IHM* et les *API* : il faut vérifier *chaque élément soumis* : saisie utilisateurs, id d'objets, widget sélectionné, headers et cookie...
====

[IMPORTANT]
====
Pour le *code* : il faut vérifier *chaque arguments de chaque fonction*, les *variables accessibles dans le scope*, les *valeurs de sorties* (qu'elles soient retournées par valeur ou via un passage par référence)
====

== Que vérifier ?

=== Disponibilité

[IMPORTANT]
====
Il faut vérifier si les données sont *présentes ou absentes* (fichiers, arguments...) et *définies* ou *indéfinies* (variables)

Il faut ensuite *accepter* ou *rejeter* chaque donnée en fonction de résultat et de leur caractère *obligatoire* ou *facultatives*
====

=== Structure

[IMPORTANT]
====
Il faut valider la structure et vérifier que *la donnée est bien formée*

Il faut utiliser des éléments *existants*, bien *testés*, et *maintenus* plutôt que de développer des solutions ad-hoc

Par exemple, on utilisera xmllint et SAX/DOM pour XML, ou RFC 4180 et librairie pour CSV
====

Par exemple, *pour un fichier XML*, on vérifiera qu'il est parsable :

* qu'il respecte de l'ordre des tags
* que les inclusions sont fonctionnelles
* que les entités sont utilisables

Par exemple, *pour un fichier CSV*, on vérifiera :

* que le caractère de séparation est celui attendu
* que le nombre de champs est constants entre les records
* que le header est présent ou absent selon ce qui est attendu
* que l'échappement des caractères de séparation est bien fait









est ce que la donnée est du type




- le type de chaque fragment de données : entier, flotant, booléen, chaîne de caractères
- les valeurs : positif, nul, négatif, plage de valeurs, ensemble de valeurs, majuscule/minuscule, expression régulières

En cas de données non-valides :

- une application génèrera des erreurs, qu'elle loggera et présentera à l'utilisateur, rejettera les données et arrêtera le traitement au plus tôt
- un module applicatif interne génèrera une exception, loggera l'erreur, annulera les tâches en cours dont il a la responsabilité, et remontera l'exception à l'appelant, qui décidera du comportement à adopter face à l'erreur (en général, annulation)
- au sein d'un même module, une fonction interne appelée par une autre fonction interne validera chaque paramètre à l'aide d'assertions

Important :

- les assertions doivent être actives pour tous les environnements, à l'exception de la production afin d'avoir la possibilité de détecter chaque erreur de conception.
- dans tous les cas, les vérifications de type doivent être faites *avant* conversion automatique, et les vérifications de valeur/plages doivent être *après* conversion éventuelle
- la vérification multiple d'une même donnée, au fur et à mesure de la chaîne d'appel, permet de garantir l'intégrité à tous les étages, à rester valide quelles que soient les évolutions, notamment à détecter rapidement et facilement les erreurs lors de refactorisations

Exemple : pour un script S qui prend un argument numérique, qui appelle une web-service W, qui lui utilise une fonction F, le script S doit vérifier le fait que l'argument soit donné s'il est obligatoire, qu'il est de type entier, que la valeur est autorisée. Le web-service W doit effectuer la même vérification (type, valeur) car le script ne sera peut-être pas le seul point d'entrée du web-service. La fonction F doit effectuer la même vérification (type, valeur) pour les mêmes raisons.

== Gestion d'erreurs

[quote]
Build to fail and fail nicely

Dans la partie <<Validation systématique des données>> nous avons pu voir que la vérification des données entraîne soit une acceptation soit un rejet de celles-ci.

Dans la présente partie, nous aborderons *les traitements relatifs au rejet des données*.

=== Différentes politiques

Nous avons aussi vu qu'un projet, une application, un programme sont découpés en composants, et ces composants peuvent être de deux types :

* des composants purement internes
* des composants ouverts à l'extérieur
** dont ceux interagissant avec des composants externes "machine"
** dont ceux intéragissant avec des éléments externes "humains"

Ce découpage permettra de définir différentes consignes de rejet, décrites ci-dessous

=== Rejet internes

On appellera *composant interne* tout composant dont l'appel *utilise la même technique que l'appelant*. Par exemple : une requête web mappée sur une classe php, une classe qui lit un fichier, un script qui prend des arguments...

==== Bas niveau

Au sein d'un composant interne *de bas niveau*, on pourra utiliser des *vérifications faibles* qui visent à *éliminer les erreurs grossières* lors de la réalisation

[IMPORTANT]
====
Il faut *positionner des assertions* vérifiant les *valeurs* de *chaque paramètre*
====

[IMPORTANT]
====
Les assertions doivent être *actives sur l'ensemble des environnements* (dev, recette, pre-prod) pour détecter le plus grand nombre de problèmes, *à l'exception de la production* pour des raisons de performances
====

==== Niveaux intermédiaires

Entre les composants internes, il faut *vérifier la cohérence de l'ensemble* et *informer les appelants* en cas de situation anormale.

L'outil de choix pour ces vérifications sont les *exceptions*.

[IMPORTANT]
====
Il *lever une exception* pour chaque *situation non gérée* ou *donnée incorrecte*
====

[IMPORTANT]
====
Il faut *varier les types* d'exception pour *permettre un traitement particulier* éventuel de chacune

Il faut *regrouper hiérarchiquement* les exceptions pour *segmenter les couches* de middleware
====

[IMPORTANT]
====
Une couche *supérieure* doit *attraper toutes les exceptions* des couches *inférieures*

Une couche ne doit remonter *que* des exceptions *de son propre type*
====

Exemple d'un générateur de site web :

* Consitution
** Le _module principal_ utilise un _module de parsing_, un _module de transformation_, et un _module de sortie_
** Les _modules de parsing_ et le _module de sortie_ utilisent un _module de gestion de fichiers_.
* Exceptions
** le module de gestion de fichier lève des sous classes de `FileExceptions`
** le module de parsing lève des sous classes de `ParsingException`
** le module de transformation lève des sous classes de `TransformException`
** le module de sortie lève des sous classes de `OutputException`
** le module principal lève des `GeneralException`
* Application des consignes
** le _module de parsing_ et le _module de sortie_ *doivent* attraper *toutes* les `FileExceptions`
** le _modules général_ *doit* attraper *toutes* les `ParsingException`, `TransformException` et `OutputException`
** chaque module *ne doit* remonter *que* ses *propres exceptions*
** aucun module de niveau `N+2` *ne doit jamais* voir passer des exceptions d'un niveau `N`

=== Rejet externes

[quote]
Be expressive about your failures

On appellera *composant ouvert à l'extérieur* tout composant dont l'appel *nécessite une transition technique depuis l'appelant*. Par exemple : une requête web mappée sur une classe php, un script qui mappe sur une classe...

[IMPORTANT]
====
Il faut *systématiquement* remonter une information technique *condensée* pouvant *informer les machines* qu'une erreur *a eu lieu*
====

[IMPORTANT]
====
Il faut pouvoir remonter une *information textuelle détaillée* pouvant *informer les éventuel humain* du *détail de l'erreur* qui a eu lieu
====
